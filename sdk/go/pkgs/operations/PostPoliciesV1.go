// WARNING: This file was generated by PrimeCodeGen. DO NOT EDIT.

package operations

import (
	"context"
	"net/http"

	"github.com/go-resty/resty/v2"
	"github.com/primelib/primecodegen-lib-go/requeststruct"
	"github.com/primelib/webmethods-api-gateway-client/sdk/go/pkgs/models"
)

type PostPoliciesV1Request struct {
	Action      *string                  `queryParam:"style=simple,explode=false,name=action"`      // This query parameter represents the action user want to perform. Currently user can only clone the policy. Hence the allowed value for this parameter would be "clone". Cloning is duplication of one or more policies in to a single policy. All the policy actions specified inside the policies are also be duplicated while creating the duplicate policy.The effective policy is not calculated for this until this policy is referred from the API.
	PolicyIDS   *string                  `queryParam:"style=simple,explode=false,name=policyIds"`   // This query parameter represents the list of policies from which the new clone policy is created. If you specify list of policies then the newly  created policy has all the policy action from all the policies.
	PolicyScope *string                  `queryParam:"style=simple,explode=false,name=policyScope"` // This query parameter represents the policy scope of cloned policy. We can clone policy from one policy scope to another policy scope. Allowed policy scope values are global,service,template & scope
	Payload     *models.PolicyMgmtPolicy `bodyParam:""`
}

type PostPoliciesV1Response struct {
	// Success response
	Result *models.PolicyMgmtPolicy
	// Error response
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
}

// PostPoliciesV1 This REST request is used to create a policy in API Gateway. The body of this request should contain the payload of the policy. Using this request we can create Policies of different type.  To create a service, scope, package and template level policy we can add the policy payload and set the corresponding policy scope.  To create a Global policy user should have API Gateway Administrator access. Other users cannot create global policies. To Create Global policy send the policy payload along with scope details and policy scope set to global. Similarly, to create a threat protection policy user have to send the policy along with the policy enforcement id of Threat protection policy actions. The policy actions needs to be created before adding the enforcement id of policy actions to policy. Threat protection rules are another type of global level policies which are applied to all requests and responses. The threat protection policy enforcement cannot be used in any other policies and other policy enforcement cannot be used in threat protection policies.  Using this request we can also clone a policy. To clone a policy user have to set the appropriate query parameters.  The effective policy calculation for policy(Service and scope level policy) is not calculated till it is referred in the API. But for a  global policy the effective policy is calculated while creating the policy itself. Policy with template as policy scope cannot be referred from any API or scope. User needs to clone the policy templates and set the policy scope to either service or scope or global before referring it from the API. Policy should have only one occurrence of any stage. Multiple policy enforcements can be added to the applicable stages. To know about the list of stages and applicable policy enforcements on that stage please refer /policyStages resource.
//
//meta:operation POST /policies
func PostPoliciesV1(client *resty.Client, ctx context.Context, req PostPoliciesV1Request) (*PostPoliciesV1Response, error) {
	r := client.R().SetContext(ctx)

	// process request parameters
	reqData, err := requeststruct.ResolveRequestParams(req)
	if err != nil {
		return nil, err
	}
	r.SetHeader("Content-Type", "application/json")
	r.SetHeader("Accept", "application/json")
	r.SetHeaders(reqData.HeaderParams)
	r.SetPathParams(reqData.PathParams)
	r.SetQueryParamsFromValues(reqData.QueryParams)
	if reqData.BodyParam != nil {
		r.SetBody(reqData.BodyParam)
	}
	result := new(models.PolicyMgmtPolicy)
	r.SetResult(result)

	// send the request
	resp, err := r.Post("/policies")
	if err != nil {
		return nil, err
	}

	return &PostPoliciesV1Response{
		StatusCode:  resp.StatusCode(),
		RawResponse: resp.RawResponse,
		Result:      result,
	}, nil
}
