// WARNING: This file was generated by PrimeCodeGen. DO NOT EDIT.

package operations

import (
	"context"
	"net/http"

	"github.com/go-resty/resty/v2"
	"github.com/primelib/primecodegen-lib-go/requeststruct"
	"github.com/primelib/webmethods-api-gateway-client/sdk/go/pkgs/models"
)

type CheckConflictForGlobalPolicyRequest struct {
	PolicyId *string `pathParam:"style=simple,explode=false,name=policyId"` // This path parameter is used to specify the global policy id to which we need to conflicting case for a global policy
	Active   *string `queryParam:"style=simple,explode=false,name=active"`  // This is a query parameter. It is used to get conflicting case for a global policy. If the value for this parameter is 'false' then it will return conflicting scenario for all the APIs whether it is active or not for the specified global policy. If the value for this flag is 'true' then it will return conflicting case only for the list of applicable active APIs alone
}

type CheckConflictForGlobalPolicyResponse struct {
	// Success response
	Result *models.PolicyMgmtPolicy
	// Error response
	// HTTP response status code for this operation
	StatusCode int
	// Raw HTTP response; suitable for custom response parsing
	RawResponse *http.Response
}

// CheckConflictForGlobalPolicy This REST Request is used to get the conflicts for a global policy. Conflicts between the policies/APIs can arise if the policies contain the conflicting policy actions. For example, a global policy that contains the Identity and Access Policy with "API Key" will conflict with another global policy that contains the Identity and Access Policy with "OAuth2". If an API satisfy more than one global policy, then all the policy actions of all applicable global policy will be added for effective policy calculation. If any policy validation error occurred it will be reported as conflict.  This REST request doesn't require request body. By Default it will return the conflicts for all applicable APIs and conflicts between the specified global policy and other active global policies. Additionally, we can use the query parameter to get the conflicts for active or all applicable APIs.   If there is conflict, status 500 is returned along with the details on conflicting scenarios and if there is no conflict then status 200 is returned
//
//meta:operation GET /policies/{policyId}/conflicts
func CheckConflictForGlobalPolicy(client *resty.Client, ctx context.Context, req CheckConflictForGlobalPolicyRequest) (*CheckConflictForGlobalPolicyResponse, error) {
	r := client.R().SetContext(ctx)

	// process request parameters
	reqData, err := requeststruct.ResolveRequestParams(req)
	if err != nil {
		return nil, err
	}
	r.SetHeader("Accept", "application/json")
	r.SetHeaders(reqData.HeaderParams)
	r.SetPathParams(reqData.PathParams)
	r.SetQueryParamsFromValues(reqData.QueryParams)
	if reqData.BodyParam != nil {
		r.SetBody(reqData.BodyParam)
	}
	result := new(models.PolicyMgmtPolicy)
	r.SetResult(result)

	// send the request
	resp, err := r.Get("/policies/{policyId}/conflicts")
	if err != nil {
		return nil, err
	}

	return &CheckConflictForGlobalPolicyResponse{
		StatusCode:  resp.StatusCode(),
		RawResponse: resp.RawResponse,
		Result:      result,
	}, nil
}
